#!/usr/bin/env python3

"""Initial implementation of draft-ymbk-lsvr-lsoe-02 (LSOE).

Be warned that the specification is in flux, we don't expect -02 to be
the final protocol.
"""

# Implementation notes:
#
# * Currently written using the third-party Tornado package, because I
#   know that API better than I know Python3's native asyncio API.  At
#   some point we'll probably rewrite this to use asyncio directly,
#   which may remove the need for Tornado.
#
# * We don't have a real EtherType yet, because IEEE considers them a
#   scarce resource and won't allocate until the specification is
#   cooked.  So for now we use one of the "playground" EtherTypes IEEE
#   set aside for use for exactly this purpose.

import time
import socket
import struct
import logging
import collections

import tornado.gen
import tornado.locks
import tornado.ioloop
import tornado.queues

ETH_DATA_LEN    = 1500          # Max. octets in payload
ETH_FRAME_LEN   = 1514          # Max. octets in frame sans FCS

ETH_P_ALL       = 0x0003        # Everything
ETH_P_IP        = 0x0800        # IPv4
ETH_P_IPV6      = 0x86DD        # IPv6
ETH_P_IEEE_EXP1 = 0x8885        # "Local Experimental EtherType 1"
ETH_P_IEEE_EXP2 = 0x8886        # "Local Experimental EtherType 2"

ETH_P_LSOE = ETH_P_IEEE_EXP1

# Order here must match the address tuples generated by the socket module for PF_PACKET
SockAddrLL = collections.namedtuple("Sockaddr_LL",
                                    ("ifname", "protocol", "pkttype", "arptype", "macaddr"))

# May end up moving header formats into classes, sort that out as we go.

# 5.2.1. Frame TLV
frame_header_format = "!BBHLBB"

# 5.2.1: Type codes
for i, n in enumerate(("HELLO", "OPEN","KEEPALIVE", "ENCAPSULATION_ACK",
                       "IPV4_ANNOUNCEMENT", "IPV6_ANNOUNCEMENT",
                       "MPLS_IPV4_ANNOUNCEMENT", "MPLS_IPV6_ANNOUNCEMENT")):
    globals()["LSOE_" + n] = i

# 5.2.1: Flags
LSOE_IS_MULTI_FRAME   = 1 << 0
LSOE_LAST_MULTI_FRAME = 1 << 1

class EtherFrame(object):

    # Need a better scheme for naming all these fields.
    # Might require nested classes or something.

    def __init__(self, bytes, sa_ll, timestamp = None):
        self.bytes     = bytes
        self.sa_ll     = sa_ll
        self.timestamp = timestamp
        if bytes:
            self.unpack_header()

    def unpack_header(self):
        (self.version,  self.type, self.pdu_length, self.checksum, self.pdu_number, self.flags
        ) = struct.unpack(frame_header_format, self.bytes)

class EtherIO(object):

    def __init__(self):

        # Where we stash frames we haven't yet assembled into messages
        self.frames = []

        # Queue interface between receive handler and co-routines
        self.q = tornado.queues.Queue()

        self.s = socket.socket(socket.PF_PACKET, socket.SOCK_DGRAM, socket.htons(ETH_P_LSOE))
        # Do we need to do anything with multicast setup here?

        # Configure event callbacks
        self.ioloop = tornado.ioloop.IOLoop.current()
        self.ioloop.add_handler(self.s, self._handle_read,  tornado.ioloop.READ)
        self.ioloop.add_handler(self.s, self._handle_error, tornado.ioloop.ERROR)

        # Configure garbage collection of fragment queue
        self.ioloop.PeriodicCallback(self._gc_frag_queue, fragment_gc_seconds * 500)

        # Will need to self.ioloop.spawn_callback() our coroutine pseudo-threads
        # once we know what they look like

    def close(self):
        self.ioloop.remove_handler(self.s)

    def _handle_read(self, events):
        pkt, sa_ll = s.recvfrom(ETH_DATA_LEN)
        sa_ll = SockAddrLL(*sa_ll)
        msg = EtherFrame(pkt, sa_ll, time.time())
        if msg.is_multi_frame:
            msg = msg.try_reassembly(self.frames)
        if msg is not None:
            self.q.put_nowait(msg)

    def _gc_frag_queue(self):
        threshold = time.time() - fragment_gc_seconds
        while self.frames and self.frame[0].timestamp < threshold:
            del self.frame[0]

    @tornado.gen.coroutine
    def read(self):
        msg = yield self.q.get()
        return msg

    # Hmm, should this take a frame or a message?
    @tornado.gen.coroutine
    def write(self, frame):
        self.s.sendto(frame.bytes, (frame.ifname, frame.protocol, 0, 0, frame.macaddr))
