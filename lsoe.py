#!/usr/bin/env python3

"""Initial implementation of draft-ymbk-lsvr-lsoe-02 (LSOE).

Be warned that the specification is in flux, we don't expect -02 to be
the final protocol.
"""

# Implementation notes:
#
# * Currently written using the third-party Tornado package, because I
#   know that API better than I know Python3's native asyncio API.  At
#   some point we'll probably rewrite this to use asyncio directly,
#   which may remove the need for Tornado.
#
# * We don't have a real EtherType yet, because IEEE considers them a
#   scarce resource and won't allocate until the specification is
#   cooked.  So for now we use one of the "playground" EtherTypes IEEE
#   set aside for use for exactly this purpose.

import time
import socket
import struct
import logging
import collections

import tornado.gen
import tornado.locks
import tornado.ioloop
import tornado.queues

# Ethernet physical layer contstants from linux/if_ether.h, with additions.

ETH_DATA_LEN    = 1500          # Max. octets in payload
ETH_FRAME_LEN   = 1514          # Max. octets in frame sans FCS

ETH_P_ALL       = 0x0003        # All packets
ETH_P_IP        = 0x0800        # IPv4
ETH_P_IPV6      = 0x86DD        # IPv6
ETH_P_IEEE_EXP1 = 0x8885        # "Local Experimental EtherType 1"
ETH_P_IEEE_EXP2 = 0x8886        # "Local Experimental EtherType 2"

ETH_P_LSOE      = ETH_P_IEEE_EXP1

# Linux PF_PACKET API constants from linux/if_packet.h.

PACKET_HOST	 = 0
PACKET_BROADCAST = 1
PACKET_MULTICAST = 2
PACKET_OTHERHOST = 3
PACKET_OUTGOING	 = 4

# Order here must match the address tuples generated by the socket module for PF_PACKET
SockAddrLL = collections.namedtuple("Sockaddr_LL",
                                    ("ifname", "protocol", "pkttype", "arptype", "macaddr"))

LSOE_VERSION = 0

# 5.2.1: Type codes
for i, n in enumerate(("HELLO", "OPEN","KEEPALIVE", "ENCAPSULATION_ACK",
                       "IPV4_ANNOUNCEMENT", "IPV6_ANNOUNCEMENT",
                       "MPLS_IPV4_ANNOUNCEMENT", "MPLS_IPV6_ANNOUNCEMENT")):
    globals()["LSOE_" + n] = i

# Magic parameters which ought to come from a configuration file

lsoe_msg_reassembly_timeout = 1 # seconds
lsoe_macaddrdb_timeout = 300    # Seconds, number pulled out of a hat

class MACAddrDB(object):

    # MAC address interface database.  Don't touch instances directly,
    # use the class methods to act on the database as a whole.

    _db = {}

    def __init__(self, macaddr, ifname):
        self.macaddr = macaddr
        self.ifname = ifname

    @classmethod
    def ok(cls, macaddr, ifname):
        try:
            return cls._db.get[macaddr].ifname == ifname
        except KeyError:
            return True

    @classmethod
    def get(cls, macaddr):
        return cls._db[macaddr].ifname

    @classmethod
    def update(cls, macaddr, ifname):
        try:
            self = cls._db[macaddr]
        except KeyError:
            self = cls._db[macaddr] = cls(macaddr, ifname)
        self.timestamp = time.time()    

    @classmethod
    def remove(cls, macaddr):
        del cls._db[macaddr]

    # Invocation cycle of this function should be tied to KEEPALIVE
    # timeout configuration, as of course should entry timeout itself.
    @classmethod
    def gc(cls):
        threshold = time.time() - lsoe_macaddrdb_timeout
        for macaddr in cls._db.keys():
            if cls._db[macaddr].timestamp < threshold:
                cls.remove(macaddr)

class Datagram(object):

    header     = struct.Struct("!BBHL")
    LAST_FLAG  = 0x80

    _sbox = (0xa3,0xd7,0x09,0x83,0xf8,0x48,0xf6,0xf4,0xb3,0x21,0x15,0x78,
             0x99,0xb1,0xaf,0xf9,0xe7,0x2d,0x4d,0x8a,0xce,0x4c,0xca,0x2e,
             0x52,0x95,0xd9,0x1e,0x4e,0x38,0x44,0x28,0x0a,0xdf,0x02,0xa0,
             0x17,0xf1,0x60,0x68,0x12,0xb7,0x7a,0xc3,0xe9,0xfa,0x3d,0x53,
             0x96,0x84,0x6b,0xba,0xf2,0x63,0x9a,0x19,0x7c,0xae,0xe5,0xf5,
             0xf7,0x16,0x6a,0xa2,0x39,0xb6,0x7b,0x0f,0xc1,0x93,0x81,0x1b,
             0xee,0xb4,0x1a,0xea,0xd0,0x91,0x2f,0xb8,0x55,0xb9,0xda,0x85,
             0x3f,0x41,0xbf,0xe0,0x5a,0x58,0x80,0x5f,0x66,0x0b,0xd8,0x90,
             0x35,0xd5,0xc0,0xa7,0x33,0x06,0x65,0x69,0x45,0x00,0x94,0x56,
             0x6d,0x98,0x9b,0x76,0x97,0xfc,0xb2,0xc2,0xb0,0xfe,0xdb,0x20,
             0xe1,0xeb,0xd6,0xe4,0xdd,0x47,0x4a,0x1d,0x42,0xed,0x9e,0x6e,
             0x49,0x3c,0xcd,0x43,0x27,0xd2,0x07,0xd4,0xde,0xc7,0x67,0x18,
             0x89,0xcb,0x30,0x1f,0x8d,0xc6,0x8f,0xaa,0xc8,0x74,0xdc,0xc9,
             0x5d,0x5c,0x31,0xa4,0x70,0x88,0x61,0x2c,0x9f,0x0d,0x2b,0x87,
             0x50,0x82,0x54,0x64,0x26,0x7d,0x03,0x40,0x34,0x4b,0x1c,0x73,
             0xd1,0xc4,0xfd,0x3b,0xcc,0xfb,0x7f,0xab,0xe6,0x3e,0x5b,0xa5,
             0xad,0x04,0x23,0x9c,0x14,0x51,0x22,0xf0,0x29,0x79,0x71,0x7e,
             0xff,0x8c,0x0e,0xe2,0x0c,0xef,0xbc,0x72,0x75,0x6f,0x37,0xa1,
             0xec,0xd3,0x8e,0x62,0x8b,0x86,0x10,0xe8,0x08,0x77,0x11,0xbe,
             0x92,0x4f,0x24,0xc5,0x32,0x36,0x9d,0xcf,0xf3,0xa6,0xbb,0xac,
             0x5e,0x6c,0xa9,0x13,0x57,0x25,0xb5,0xe3,0xbd,0xa8,0x3a,0x01,
             0x05,0x59,0x2a,0x46)

    def __init__(self, bytes, sa_ll, version, frag, length, checksum, timestamp = None):
        self.bytes     = bytes
        self.sa_ll     = sa_ll
        self.version   = version
        self.frag      = frag
        self.length    = length
        self.checksum  = checksum
        self.timestamp = timestamp

    @classmethod
    def incoming(cls, bytes, sa_ll):
        version, frag, length, checksum = cls.header.unpack(bytes)
        if length > len(bytes):
            bytes = bytes[:length]
        return cls(
            bytes     = bytes,
            sa_ll     = sa_ll,
            version   = version,
            frag      = frag,
            length    = length,
            checksum  = checksum,
            timestamp = time.time())

    def verify(self):
        return self.version == LSOE_VERSION and \
            len(self.bytes) == self.length and \
            self.checksum == self._sbox_checksum(
                self.bytes[self.header.size:], self.frag, self.length)

    @classmethod
    def outgoing(cls, bytes, sa_ll, frag, last):
        if last:
            frag |= Datagram.LAST_FLAG
        length = cls.header.size + len(bytes)
        cksum  = cls._sbox_checksum(bytes, frag, length)
        hdr    = cls.header.pack(LSOE_VERSION, frag, length, cksum)
        return cls(
            bytes     = hdr + bytes,
            sa_ll     = sa_ll,
            version   = LSOE_VERSION,
            frag      = frag,
            length    = length,
            checksum  = cksum)

    @property
    def is_final(self):
        return self.frag & self.LAST_FLAG != 0

    @property
    def dgram_number(self):
        return self.frag & ~self.LAST_FLAG

    @classmethod
    def _sbox_checksum(cls, bytes, frag, length):
        pkt = cls.header.pack(LSOE_VERSION, frag, length, 0) + bytes
        sum, result = [0, 0, 0, 0], 0
        for i, b in enumerate(pkt):
            sum[i & 3] += self._sbox[b]
        for i in xrange(4):
            result = (result << 8) + sum[i]
        for i in xrange(2):
            result = (result >> 32) + (result & 0xFFFFFFFF)
        return result

    @property
    def payload(self):
        return self.bytes[self.header.size : self.header.size + self.length]

class Message(object):

    def __init__(self, macaddr, bytes = None, dgrams = None):
        self.macaddr = macaddr
        self.dgrams = dgrams
        self.bytes = bytes

    @classmethod
    def incoming(self, dgrams):
        assert all(d.sa_ll.macaddr == dgrams[0].sa_ll.macaddr for d in dgrams)
        assert all(d.sa_ll.ifname  == dgrams[0].sa_ll.ifname  for d in dgrams)
        return cls(
            macaddr = dgrams[0].sa_ll.macaddr,
            dgrams  = dgrams,
            bytes   = b"".join(d.payload for d in dgrams))

    def split_into_dgrams(self):
        sa_ll = SockAddrLL(macaddr  = self.macaddr,
                           ifname   = MACAddrDB.get(self.macaddr),
                           protocol = ETH_P_LSOE,
                           pkttype  = 0,
                           arptype  = 0)
        self.dgrams = []
        n = ETH_DATA_LEN - Datagram.header.size
        for i in xrange(0, len(self.bytes), n):
            bytes = self.bytes[i : i + n]
            self.dgrams.append(Datagram.outgoing(bytes, sa_ll, i / n, i + n >= len(self.bytes)))
        return self.dgrams

class EtherIO(object):

    def __init__(self):
        self.dgrams = {}
        self.q = tornado.queues.Queue()
        self.s = socket.socket(socket.PF_PACKET, socket.SOCK_DGRAM, socket.htons(ETH_P_LSOE))
        # Do we need to do anything with multicast setup here?
        self.ioloop = tornado.ioloop.IOLoop.current()
        self.ioloop.add_handler(self.s, self._handle_read,  tornado.ioloop.READ)
        self.ioloop.add_handler(self.s, self._handle_error, tornado.ioloop.ERROR)
        # .PeriodicCallback() wants milliseconds, not seconds, so multiplying
        # by 500 gets two GC calls per timeout interval.
        self.ioloop.PeriodicCallback(self._gc, lsoe_msg_reassembly_timeout * 500)
        # Probably need one or more self.ioloop.spawn_callback() calls here

    def _handle_read(self, events):
        # Allow duplication and reordering, disallow other
        # inconsistencies.  We do, however, need to support receiving
        # from multiple MAC addresses in parallel, so each peer
        # address gets its own reassembly queue and GC has to deal.

        pkt, sa_ll = s.recvfrom(ETH_DATA_LEN)
        if len(pkt) < Datagram.header.size:
            return
        sa_ll = SockAddrLL(*sa_ll)
        assert sa_ll.protocol == ETH_P_LSOE
        if sa_ll.pkttype = PACKET_OUTGOING:
            return
        if not MACAddrDB.ok(sa_ll.macaddr, sa_ll.ifname):
            # Should yell about MAC address appearing on wrong interface here
            return
        MACAddrDB.update(sa_ll.macaddr, sa_ll.ifname)
        d = Datagram.incoming(pkt, sa_ll)
        if not d.verify():
            return
        try:
            rq = self.dgrams[sa_ll.macaddr]
        except KeyError:
            rq = self.dgrams[sa_ll.macaddr] = []
        rq.append(d)
        rq.sort(key = lambda d: (d.dgram_number, -d.timestamp))
        if not rq[-1].is_final:
            return None
        rq[:] = [d for i, d in enumerate(rq) if d.dgram_number >= i]
        for i, d in enumerate(rq):
            if d.dgram_number != i or d.is_final != (d is rq[-1]):
                return
        del self.dgrams[sa_ll.macaddr]
        self.q.put_nowait(Message(rq))

    def _gc(self):
        threshold = time.time() - lsoe_msg_reassembly_timeout
        for macaddr, rq in self.dgrams.iteritems():
            rq.sort(key = lambda d: d.timestamp)
            while rq[0].timestamp < threshold:
                del rq[0]
            if not rq:
                del self.dgrams[macaddr]

    @tornado.gen.coroutine
    def read(self):
        msg = yield self.q.get()
        return msg

    @tornado.gen.coroutine
    def write(self, msg):
        for d in msg.split_into_dgrams():
            self.s.sendto(d.bytes, d.sa_ll)

    def close(self):
        self.ioloop.remove_handler(self.s)
