#!/usr/bin/env python3

"""Initial implementation of draft-ymbk-lsvr-lsoe-02 (LSOE).

Be warned that the specification is in flux, we don't expect -02 to be
the final protocol.
"""

# Implementation notes:
#
# * Currently written using the third-party Tornado package, because I
#   know that API better than I know Python3's native asyncio API.  At
#   some point we'll probably rewrite this to use asyncio directly,
#   which may remove the need for Tornado.
#
# * We don't have a real EtherType yet, because IEEE considers them a
#   scarce resource and won't allocate until the specification is
#   cooked.  So for now we use one of the "playground" EtherTypes IEEE
#   set aside for use for exactly this purpose.

import time
import socket
import struct
import logging
import collections

import tornado.gen
import tornado.locks
import tornado.ioloop
import tornado.queues

ETH_DATA_LEN    = 1500          # Max. octets in payload
ETH_FRAME_LEN   = 1514          # Max. octets in frame sans FCS

ETH_P_ALL       = 0x0003        # Everything
ETH_P_IP        = 0x0800        # IPv4
ETH_P_IPV6      = 0x86DD        # IPv6
ETH_P_IEEE_EXP1 = 0x8885        # "Local Experimental EtherType 1"
ETH_P_IEEE_EXP2 = 0x8886        # "Local Experimental EtherType 2"

ETH_P_LSOE = ETH_P_IEEE_EXP1

# Order here must match the address tuples generated by the socket module for PF_PACKET
SockAddrLL = collections.namedtuple("Sockaddr_LL",
                                    ("ifname", "protocol", "pkttype", "arptype", "macaddr"))

# May end up moving header formats into classes, using the
# struct.Struct class, etc, sort that out as we go.  May also end up
# wrapping some syntactic sugar around all these enums and format
# codes and ....

frame_header_format    = "!BBHL"
FRAME_HEADER_LAST_FRAG = 0x80

# 5.2.1: Type codes
for i, n in enumerate(("HELLO", "OPEN","KEEPALIVE", "ENCAPSULATION_ACK",
                       "IPV4_ANNOUNCEMENT", "IPV6_ANNOUNCEMENT",
                       "MPLS_IPV4_ANNOUNCEMENT", "MPLS_IPV6_ANNOUNCEMENT")):
    globals()["LSOE_" + n] = i

class EtherFrame(object):

    # Need a better scheme for naming all these fields.
    # Might require nested classes or something.

    _sbox = (0xa3,0xd7,0x09,0x83,0xf8,0x48,0xf6,0xf4,0xb3,0x21,0x15,0x78,
             0x99,0xb1,0xaf,0xf9,0xe7,0x2d,0x4d,0x8a,0xce,0x4c,0xca,0x2e,
             0x52,0x95,0xd9,0x1e,0x4e,0x38,0x44,0x28,0x0a,0xdf,0x02,0xa0,
             0x17,0xf1,0x60,0x68,0x12,0xb7,0x7a,0xc3,0xe9,0xfa,0x3d,0x53,
             0x96,0x84,0x6b,0xba,0xf2,0x63,0x9a,0x19,0x7c,0xae,0xe5,0xf5,
             0xf7,0x16,0x6a,0xa2,0x39,0xb6,0x7b,0x0f,0xc1,0x93,0x81,0x1b,
             0xee,0xb4,0x1a,0xea,0xd0,0x91,0x2f,0xb8,0x55,0xb9,0xda,0x85,
             0x3f,0x41,0xbf,0xe0,0x5a,0x58,0x80,0x5f,0x66,0x0b,0xd8,0x90,
             0x35,0xd5,0xc0,0xa7,0x33,0x06,0x65,0x69,0x45,0x00,0x94,0x56,
             0x6d,0x98,0x9b,0x76,0x97,0xfc,0xb2,0xc2,0xb0,0xfe,0xdb,0x20,
             0xe1,0xeb,0xd6,0xe4,0xdd,0x47,0x4a,0x1d,0x42,0xed,0x9e,0x6e,
             0x49,0x3c,0xcd,0x43,0x27,0xd2,0x07,0xd4,0xde,0xc7,0x67,0x18,
             0x89,0xcb,0x30,0x1f,0x8d,0xc6,0x8f,0xaa,0xc8,0x74,0xdc,0xc9,
             0x5d,0x5c,0x31,0xa4,0x70,0x88,0x61,0x2c,0x9f,0x0d,0x2b,0x87,
             0x50,0x82,0x54,0x64,0x26,0x7d,0x03,0x40,0x34,0x4b,0x1c,0x73,
             0xd1,0xc4,0xfd,0x3b,0xcc,0xfb,0x7f,0xab,0xe6,0x3e,0x5b,0xa5,
             0xad,0x04,0x23,0x9c,0x14,0x51,0x22,0xf0,0x29,0x79,0x71,0x7e,
             0xff,0x8c,0x0e,0xe2,0x0c,0xef,0xbc,0x72,0x75,0x6f,0x37,0xa1,
             0xec,0xd3,0x8e,0x62,0x8b,0x86,0x10,0xe8,0x08,0x77,0x11,0xbe,
             0x92,0x4f,0x24,0xc5,0x32,0x36,0x9d,0xcf,0xf3,0xa6,0xbb,0xac,
             0x5e,0x6c,0xa9,0x13,0x57,0x25,0xb5,0xe3,0xbd,0xa8,0x3a,0x01,
             0x05,0x59,0x2a,0x46)

    def __init__(self, bytes, sa_ll, timestamp = None):
        self.bytes     = bytes
        self.sa_ll     = sa_ll
        self.timestamp = timestamp
        if bytes:
            self.unpack_header()

    def unpack_header(self):
        (self.version,  self.frag, self.length, self.checksum
        ) = struct.unpack(frame_header_format, self.bytes)

    @property
    def is_multi_frame(self):
        return self.frag != FRAME_HEADER_LAST_FRAG

    @property
    def is_final_frame(self):
        return self.frag & FRAME_HEADER_LAST_FRAG != 0

    @property
    def frame_number(self):
        return self.frag & ~FRAME_HEADER_LAST_FRAG

    def sbox_checksum(self):
        hdr = struct.pack(frame_header_format, self.version,  self.type,
                          self.pdu_length, 0, self.pdu_number, self.flags)
        pkt = hdr + self.bytes[len(hdr):]
        sum, result = [0, 0, 0, 0], 0
        for i, b in enumerate(pkt):
            sum[i & 3] += self._sbox[b]
        for i in xrange(4):
            result = (result << 8) + sum[i]
        for i in xrange(2):
            result = (result >> 32) + (result & 0xFFFFFFFF)
        return result

    @property
    def payload(self):
        return self.bytes[struct.calcsize(frame_header_format) :
                          struct.calcsize(frame_header_format) + self.length]

class EtherIO(object):

    def __init__(self):
        self.frames = []
        self.q = tornado.queues.Queue()
        self.s = socket.socket(socket.PF_PACKET, socket.SOCK_DGRAM, socket.htons(ETH_P_LSOE))
        # Do we need to do anything with multicast setup here?
        self.ioloop = tornado.ioloop.IOLoop.current()
        self.ioloop.add_handler(self.s, self._handle_read,  tornado.ioloop.READ)
        self.ioloop.add_handler(self.s, self._handle_error, tornado.ioloop.ERROR)
        self.ioloop.PeriodicCallback(self._gc_frames, fragment_gc_seconds * 500)
        # Probably need one or more self.ioloop.spawn_callback() calls here

    def _handle_read(self, events):
        pkt, sa_ll = s.recvfrom(ETH_DATA_LEN)
        sa_ll = SockAddrLL(*sa_ll)
        frame = EtherFrame(pkt, sa_ll, time.time())
        if frame.checksum != frame.sbox_checksum():
            return
        msg = self._reassemble(frame)
        if msg is not None:
            self.q.put_nowait(msg)

    def _gc_frames(self):
        threshold = time.time() - fragment_gc_seconds
        self.frames.sort(key = lambda f: f.timestamp)
        while self.frames[0].timestamp < threshold:
            del self.frames[0]

    def _reassemble(self, frame):
        if not frame.is_multi_frame:
            del self.frames[:]
            return frame.payload
        # Allow duplication and reordering, disallow other inconsistencies
        self.frames.append(frame)
        self.frames.sort(key = lambda f: (f.frame_number, -f.timestamp))
        if not self.frames[-1].is_final_frame:
            return None
        self.frames[:] = [f for i, f in enumerate(self.frames) if f.frame_number >= i]
        if any(f.is_final_frame or f.type != self.frames[-1].type for f in self.frames[:-1]) or \
           any(f.frame_number != i for i, f in enumerate(self.frames)):
            return None
        msg = b"".join(f.payload for f in self.frames)
        del self.frames[:] 
        return msg

    @tornado.gen.coroutine
    def read(self):
        msg = yield self.q.get()
        return msg

    # Hmm, should this take a frame or a message?
    @tornado.gen.coroutine
    def write(self, frame):
        self.s.sendto(frame.bytes, (frame.ifname, frame.protocol, 0, 0, frame.macaddr))

    def close(self):
        self.ioloop.remove_handler(self.s)
